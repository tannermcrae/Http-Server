
const char * usage =
"                                                               \n"
"myhttpd                                                        \n"
"                                                               \n"
"Simple server program that shows how to use socket calls       \n"
"in the server side.                                            \n"
"                                                               \n"
"To use it in one window type:                                  \n"
"                                                               \n"
"myhttpd [-f|-t|-p] [<port>]                                    \n"
"                                                               \n"
"Where 1024 < port < 65536.                                     \n"
"                                                               \n"
"In another window type:                                        \n"
"                                                               \n"
"   telnet <host> <port>                                        \n"
"                                                               \n"
"where <host> is the name of the machine where daytime-server   \n"
"is running. <port> is the port number you used when you run    \n"
"daytime-server.                                                \n"
"                                                               \n"
"Then GET <document> <crlf><crlf> to have the doc returned      \n"
"You can also type <machine_name>:<port>/<document> in a browser\n"
"to have the file show up in the browser                        \n"
"                                                               \n";


#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <time.h>
#include <fcntl.h>
#include <pthread.h>
#include <errno.h>
#include <signal.h>
#include <sys/wait.h>




int QueueLength = 5;
pthread_mutex_t mutex;
struct sigaction sigAction;

// Processes time request
void processRequest( int socket );
void processRequestThread( int socket);
int cmpReversedString(char *revString, char *fileExt);
void write404(int socket);
void writeRequest(int socket, int file, char *document, char *contentType);
void poolSlave(int socket);
void sigHandler(int sig);
int main( int argc, char ** argv ) {
   // Set up zombie stuff
   sigAction.sa_handler = sigHandler;
   sigemptyset(&sigAction.sa_mask);
   sigAction.sa_flags = SA_RESTART;
   // int error = sigaction(SIGINT, &sigAction, NULL );
   // if ( error ) {
   //    perror( "sigaction" );
   //    exit(-1);
   // }

  // Print usage if not enough arguments
  // if ( argc < 2 ) {
  //   fprintf( stderr, "%s", usage );
  //   exit( -1 );
  // }

  // Default iterative mode
  int mode = 0; 
  // default?
  int port = 1026;
   if (argc > 1) {
      if (strcmp(argv[1], "-f") == 0)
         mode = 1;
      else if (strcmp(argv[1], "-t") == 0)
         mode = 2;
      else if (strcmp(argv[1], "-p") == 0)
         mode = 3;
      else
         port = atoi( argv[1] );
   }
   if(argv[2])
      port = atoi(argv[2]);

   fprintf(stderr, "mode %d\n", mode);
   fprintf(stderr, "port %d\n", port);
  
  // Set the IP address and port for this server
  struct sockaddr_in serverIPAddress; 
  memset( &serverIPAddress, 0, sizeof(serverIPAddress) );
  serverIPAddress.sin_family = AF_INET;
  serverIPAddress.sin_addr.s_addr = INADDR_ANY;
  serverIPAddress.sin_port = htons((u_short) port);
  
  // Allocate a socket
  int masterSocket =  socket(PF_INET, SOCK_STREAM, 0);
  if ( masterSocket < 0) {
    perror("socket");
    exit( -1 );
  }

  // Set socket options to reuse port. Otherwise we will
  // have to wait about 2 minutes before reusing the sae port number
  int optval = 1; 
  int err = setsockopt(masterSocket, SOL_SOCKET, SO_REUSEADDR, 
		       (char *) &optval, sizeof( int ) );
   
  // Bind the socket to the IP address and port
  int error = bind( masterSocket,
		    (struct sockaddr *)&serverIPAddress,
		    sizeof(serverIPAddress) );
  if ( error ) {
    perror("bind");
    exit( -1 );
  }
  
  // Put socket in listening mode and set the 
  // size of the queue of unprocessed connections
  error = listen( masterSocket, QueueLength);
  if ( error ) {
    perror("listen");
    exit( -1 );
  }

   if (mode == 0) {
      while ( 1 ) {
         // Accept incoming connections
         struct sockaddr_in clientIPAddress;
         int alen = sizeof( clientIPAddress );
         int slaveSocket = accept( masterSocket,
  			      (struct sockaddr *)&clientIPAddress,
  			      (socklen_t*)&alen);
         if ( slaveSocket < 0 ) {
            perror( "accept" );
            exit( -1 );
         }
         processRequest( slaveSocket );
         close(slaveSocket);
      }
   }

   else if (mode == 1) {
      while ( 1 ) {
         // Accept incoming connections
         struct sockaddr_in clientIPAddress;
         int alen = sizeof( clientIPAddress );
         int slaveSocket = accept( masterSocket,
                  (struct sockaddr *)&clientIPAddress,
                  (socklen_t*)&alen);
         if ( slaveSocket < 0 ) {
            if (slaveSocket == -1 && errno == EINTR) {
               continue;
            }
            perror( "accept" );
            exit( -1 );
         }

         pid_t slave = fork();
         if(slave==0){
            processRequest(slaveSocket);
            close(slaveSocket);
            exit(0);
         }
         else if (slave < 0) {
            // Fork error
            perror("fork");
            exit(-1);
         }
         // Clean up zombie processes
         int z_error = sigaction(SIGCHLD, &sigAction, NULL);
         if ( z_error ) {
            perror( "sigaction" );
            exit(-1);
         }
         close(slaveSocket);
      }
   }
   else if (mode == 2) {
      while (1) {
         // Accept incoming connections
         fprintf(stderr, "testing1\n" );
         struct sockaddr_in clientIPAddress;
         int alen = sizeof( clientIPAddress );
         int slaveSocket = accept( masterSocket,
                               (struct sockaddr *)&clientIPAddress,
                               (socklen_t*)&alen);
               fprintf(stderr, "testing2\n" );

         if ( slaveSocket < 0 ) {
            perror( "accept" );
            exit( -1 );
         }
         pthread_t thr;
         pthread_attr_t attr;
         pthread_attr_init(&attr);
         pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
         pthread_create(&thr, &attr, (void * (*) (void *))processRequestThread, (void *)slaveSocket);
      }
   }

   else {
      // Using poolthreads
      pthread_mutex_init(&mutex, NULL);
      pthread_attr_t attr;
      pthread_attr_init(&attr);
      pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
      pthread_t tid[5];
      for(int i=0; i< 5;i++) {
         pthread_create(&tid[i], &attr, (void *(*)(void *))poolSlave, (void *)masterSocket);
         pthread_join(tid[i], NULL);
      }
   }
}

void poolSlave(int socket){
  while(1) {
      struct sockaddr_in clientIPAddress;
      int alen = sizeof( clientIPAddress );
      pthread_mutex_lock(&mutex);
      int slaveSocket = accept( socket, (struct sockaddr *)&clientIPAddress, (socklen_t*)&alen);
      if ( slaveSocket < 0 ) {
         perror( "accept" );
         exit( -1 );
      }
      pthread_mutex_unlock(&mutex);
      processRequest(slaveSocket);
      close(slaveSocket);
   }
} 

void processRequestThread(int socket) {
   processRequest(socket);
   close(socket);
}

void processRequest( int fd ) {
   char *docPath;
   int n;
   int length = 0;
   int gotGet = 0;
   int gotDocPath = 0;
   unsigned char newChar;
   unsigned char lastChar = 0;
   char *currString = (char *)malloc(sizeof(char) * 1024);
   int crlf_flag = 0;
   int loop_counter = 0;
   //
   // The client should send <name><cr><lf>
   // Read the name of the client character by character until a
   // <CR><LF> is found.
   //

   while ((n=read(fd, &newChar, sizeof(newChar))) > 0) {
      if (newChar == ' ') {
         if (gotGet == 0) {
            gotGet = 1;
         }
         else if(gotDocPath == 0) {
            currString[length-1] = '\0';
            docPath = (char *)malloc(sizeof(char) * length);
            strcpy(docPath, currString);
            fprintf(stderr, "doc path is %s\n", docPath);
            gotDocPath = 1;
         }
      }
      // Check for two crlf's in a row
      else if ( lastChar == '\015' && newChar == '\012' ) {
         if (loop_counter-2 == crlf_flag)
            break;
         else
            crlf_flag = loop_counter;
      }
      if (gotGet) {
         //fprintf(stderr, "%c",newChar );
         currString[length-1] = newChar;
         length++;
         lastChar = newChar;
      }
      loop_counter++;
   }

   // Code to get absolute filepath
   char *cwd = (char *)malloc(sizeof(char)*256);
   cwd = getcwd(cwd,256);
   char *filePath = (char *)malloc(sizeof(char)*(length + strlen(cwd) + 20));
   if (!strncmp(docPath,"/icon",5) || !strncmp(docPath, "/htdocs",7)) {
      strcpy(filePath,cwd);
      strcat(filePath,"/http-root-dir");
      strcat(filePath,docPath);
   }
   else {
      strcpy(filePath,cwd);
      strcat(filePath,"/http-root-dir/htdocs");
      strcat(filePath, docPath);
   }
   // Code to get content type
   char *contentType = (char *)malloc(sizeof(char) * 11);
   if(!cmpReversedString(filePath, (char *)".html") || !cmpReversedString(filePath,(char *)".html/"))
      strcpy(contentType,"text/html");

   if(!cmpReversedString(filePath,(char *)".gif") || !cmpReversedString(filePath,(char *)".gif/"))
      strcpy(contentType, "image/gif");

   else
      strcpy(contentType, "text/plain");


   int file = open(filePath, O_RDONLY);
   fprintf(stderr,"file path is %s | file descriptor = %d\n",filePath, file);
   // Return 404 if the file is not found
   if (file == -1)
      write404(fd);
   else
      writeRequest(fd, file, strdup(docPath), strdup(contentType));

   // // Cleanup
   //free(cwd);
   //free(currString);
   //free(docPath);
   return;
   }

   // Compare the suffix of the string for the given file extension.
   int cmpReversedString(char *s, char *fileExt) {
   int i;
   int sIndex = strlen(s) - 1;
   int feIndex = strlen(fileExt) - 1;
   for (i = feIndex; i >= 0 ; i--) {
   if (s[sIndex--] != fileExt[feIndex--])
   return 1;
   }
   return 0;
}

void writeRequest(int socket, int file, char *document, char *contentType) {
   const char *protocol = "HTTP/1.0";
   const char *responseID = "200";
   const char *followsText = "follows";
   const char *serverType =  "Server: CS 252 lab5";
   const char *contentTypeText = "Content-type:";
   const char *clrf = "\r\n";
   const char space = ' ';
   char *fileText = (char *)malloc(sizeof(char)*100);
   int fileTextSize = 100;
   char n;
   char newChar;
   int size = 0;
   while ((n=read(file, &fileText[size++], 1) > 0)) {
      if (size >= fileTextSize) {
         fileText = (char *)realloc(fileText,sizeof(char)*2*fileTextSize);
         fileTextSize *= 2;
      }
   }
   write(socket, protocol, strlen(protocol));
   write(socket, &space, 1);
   write(socket, responseID, strlen(responseID));
   write(socket, &space, 1);
   write(socket, document, strlen(document));
   write(socket, &space, 1);
   write(socket, followsText, strlen(followsText));
   write(socket, clrf, 2);
   write(socket, serverType, strlen(serverType));
   write(socket, clrf, 2);
   write(socket, contentTypeText, strlen(contentTypeText));
   write(socket, &space, 1);
   write(socket, contentType, strlen(contentType));
   write(socket, clrf,2);
   write(socket, clrf,2);
   write(socket, fileText, size); 
}

void write404(int socket) {
   const char *protocol = "HTTP/1.0";
   const char *notFound = "404 File Not Found";
   const char *serverType =  "Server: CS 252 lab5";
   const char *contentType = "Content-type: text/plain";
   const char *clrf = "\r\n";
   const char space = ' ';
   write(socket, protocol, strlen(protocol));
   write(socket, &space, 1);
   write(socket, notFound, strlen(notFound));
   write(socket, clrf, 2);
   write(socket, serverType, strlen(serverType));
   write(socket, clrf, 2);
   write(socket, contentType, strlen(contentType));
   write(socket, clrf,2);
   write(socket, clrf,2);
   write(socket, notFound, strlen(notFound)); 
}

void sigHandler(int sig) {
   int status;
   if (sig == SIGCHLD)
      while(waitpid(-1, &status, WNOHANG) > 0);
}








